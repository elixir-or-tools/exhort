defmodule Exhort.SAT.SolutonListener do
  @moduledoc false

  # Listen for responses from the model, calling `callback` for each solution.
  #
  # Solutions are transmitted in messages from a native module listener.
  #
  # The `callback` function must accept two arguments:
  # 1. A `SolverResponse` struct with the response received from the model
  # 2. An accumulator that may be used to accumulate response information from the
  #    callbacks. The accumulator is `nil` on the first callback and is then the
  #    result of the `callback` function for each subsequent response

  use GenServer

  alias Exhort.SAT.SolverResponse

  require Logger

  def start_link(builder, callback) do
    GenServer.start_link(__MODULE__, {builder, callback})
  end

  @doc """
  Stop the server.
  """
  @spec stop(pid()) :: :ok
  def stop(pid) do
    Logger.info("module=#{__MODULE__} event#stop message=Solution Listener Stopping...")
    GenServer.stop(pid)
  end

  @impl true
  def init({builder, callback}) do
    Logger.info("module=#{__MODULE__} event#init message=Solution Listener Starting...")
    {:ok, {builder, callback, nil}}
  end

  @doc """
  Get the value of the accumulator held by the server, generated by the
  `callback` function.
  """
  def acc(pid) do
    GenServer.call(pid, :acc)
  end

  @impl true
  def handle_call(:acc, _from, {_builder, _callback, acc} = state) do
    {:reply, acc, state}
  end

  @doc """
  Handle a response from the model.
  """
  @impl true
  def handle_info(response, {builder, callback, acc}) do
    solver_resp = SolverResponse.build(response, builder)
    acc = callback.(solver_resp, acc)
    Logger.info("module=#{__MODULE__} event#handle_info message=Building callback stats=#{inspect SolverResponse.stats(solver_resp)}")
    {:noreply, {builder, callback, acc}}
  end
end
